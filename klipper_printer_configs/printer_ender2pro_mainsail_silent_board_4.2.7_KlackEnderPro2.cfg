# This file contains pin mappings for the Creality "v4.2.7" board running on
# a Ender 2 Pro.
# To use this config, during "make menuconfig" select the STM32F103 with
# a "28KiB bootloader" and serial (on USART1 PA10/PA9) communication.

# If you prefer a direct serial connection, in "make menuconfig"
# select "Enable extra low-level configuration options" and select
# serial (on USART3 PB11/PB10), which is broken out on the 10 pin IDC
# cable used for the LCD module as follows:
# 3: Tx, 4: Rx, 9: GND, 10: VCC

# Flash this firmware by copying "out/klipper.bin" to a SD card and
# turning on the printer with the card inserted. The firmware
# filename must end in ".bin" and must not match the last filename
# that was flashed.

# See docs/Config_Reference.md for a description of parameters.

[stepper_x]
step_pin: PB9
dir_pin: PC2
enable_pin: !PC3
microsteps: 16
# rotation_distance: 40
# rotation_distance: 39.98001
rotation_distance: 40.53
endstop_pin: ^PA5
position_endstop: -15
position_min: -15
position_max: 180
homing_speed: 120 #100

[stepper_y]
step_pin: PB7
dir_pin: PB8
enable_pin: !PC3
microsteps: 16
# rotation_distance: 40
# rotation_distance: 39.7
rotation_distance: 40.1813625
endstop_pin: ^PA6
position_min: -5
position_endstop: -5
position_max: 170
homing_speed: 120 #100

[stepper_z]
# Creality:
step_pin: PB5
dir_pin: !PB6
enable_pin: !PC3
# Generic
# step_pin: PB6
# dir_pin: !PB5
# enable_pin: !PC3
microsteps: 16
# rotation_distance: 8
# rotation_distance: 7.92
# rotation_distance: 7.99128
rotation_distance: 7.98029199
position_max: 180
homing_speed: 25 #20 #10
# KlackEnder Probe
# endstop_pin: ^PA7
endstop_pin: probe:z_virtual_endstop #if you want to use the Prove as z-endstop (You can unsinstall the stock z endstop then. If not, remove the [homing_override])
# position_endstop: 0.0 #remove this or uncomment it with a #
position_min: -8 # set a negative value (minimum as the probe z_offset)

# https://github.com/Klipper3d/klipper/blob/master/klippy/extras/temperature_sensors.cfg
# Definition from (20211101): https://www.keenovo.com/NTC-Thermistor-R-T-Table.pdf
# [thermistor Generic 3950]
# temperature1: 25
# resistance1: 100000
# temperature2: 150
# resistance2: 1770
# temperature3: 250
# resistance3: 230

[extruder]
max_extrude_only_distance: 100.0
step_pin: PB3
dir_pin: PB4
enable_pin: !PC3
microsteps: 16
rotation_distance: 23.4045849
nozzle_diameter: 0.400 # 0.600
filament_diameter: 1.750
heater_pin: PA1
# https://github.com/Klipper3d/klipper/blob/master/klippy/extras/temperature_sensors.cfg
# sensor_type: thermistor Generic 3950
sensor_type: Generic 3950
# sensor_type: EPCOS 100K B57560G104F
sensor_pin: PC5
#control: pid
#pid_Kp: 29.634
#pid_Ki: 2.102
#pid_Kd: 104.459
# PID parameters: pid_Kp=28.358 pid_Ki=1.734 pid_Kd=115.913
# PID parameters: pid_Kp=27.731 pid_Ki=1.712 pid_Kd=112.312
# PID parameters: pid_Kp=27.328 pid_Ki=1.656 pid_Kd=112.727
#pid_Kp: 27.328
#pid_Ki: 1.656
#pid_kd: 112.727
min_temp: 0
max_temp: 250
# SET_PRESSURE_ADVANCE EXTRUDER=extruder ADVANCE=0.003
pressure_advance = 0.001
# pressure_advance = 0.003
# Pressure Advance seemed to round corners, possibly need it off or a very small value
# 0.036 - 0.039 calculated
# pressure_advance = 0.036
# pressure_advance = 0.1804
# pressure_advance = 0.072
# pressure_advance = 0.55

[heater_bed]
heater_pin: PA2
sensor_type: EPCOS 100K B57560G104F
sensor_pin: PC4
#control: pid
# PID parameters: pid_Kp=74.383 pid_Ki=1.626 pid_Kd=850.756
# PID parameters: pid_Kp=74.758 pid_Ki=1.634 pid_Kd=855.043
# PID parameters: pid_Kp=75.136 pid_Ki=1.659 pid_Kd=850.919
#pid_Kp: 75.136
#pid_Ki: 1.659
#pid_Kd: 850.919
min_temp: 0
max_temp: 90

[fan]
pin: PA0

[mcu]
serial: /dev/serial/by-id/usb-1a86_USB_Serial-if00-port0
restart_method: command

[printer]
kinematics: cartesian
max_velocity: 500 #300
max_accel: 4000 #3500
max_z_velocity: 30 #20 #15 #10
max_z_accel: 200 #100

[display]
lcd_type: st7920
cs_pin: PB12
sclk_pin: PB13
sid_pin: PB15
encoder_pins: ^PB14, ^PB10 #^PB14, ^PA3
click_pin: ^!PB2

[filament_switch_sensor filament_sensor]
pause_on_runout: True
#   When set to True, a PAUSE will execute immediately after a runout
#   is detected. Note that if pause_on_runout is False and the
#   runout_gcode is omitted then runout detection is disabled. Default
#   is True.
#runout_gcode:
#   A list of G-Code commands to execute after a filament runout is
#   detected. See docs/Command_Templates.md for G-Code format. If
#   pause_on_runout is set to True this G-Code will run after the
#   PAUSE is complete. The default is not to run any G-Code commands.
#insert_gcode:
#   A list of G-Code commands to execute after a filament insert is
#   detected. See docs/Command_Templates.md for G-Code format. The
#   default is not to run any G-Code commands, which disables insert
#   detection.
#event_delay: 3.0
#   The minimum amount of time in seconds to delay between events.
#   Events triggered during this time period will be silently
#   ignored. The default is 3 seconds.
#pause_delay: 0.5
#   The amount of time to delay, in seconds, between the pause command
#   dispatch and execution of the runout_gcode. It may be useful to
#   increase this delay if OctoPrint exhibits strange pause behavior.
#   Default is 0.5 seconds.
#switch_pin:
# switch_pin: !PC6
switch_pin: ^PA4
# switch_pin: !PC15
#   The pin on which the switch is connected. This parameter must be
#   provided.

[output_pin beeper]
pin: PC6

## Accelerometer Configuration for input_shaper
# https://www.klipper3d.org/Measuring_Resonances.html
# https://www.ifixit.com/Guide/Adding+ADXL345+Accelerometer/147745
# https://klipper.discourse.group/t/raspberry-pi-pico-adxl345-portable-resonance-measurement/1757
# https://www.reddit.com/r/klippers/comments/xqzpj1/how_to_wire_my_adxl343_correctly_to_my_raspberry/

[mcu rpi]
serial: /tmp/klipper_host_mcu

[temperature_sensor raspberry_pi]
sensor_type: temperature_host
min_temp: 10
max_temp: 100

# Example1: A led strip controlled by the GPIO20 on the RPi
[led overhead_light]
# pin: rpi:gpio20
white_pin: rpi:gpio20
initial_WHITE: 1.0
# pwm: False
# value: 1
# hardware_pwm: True
# You can also write the pin in extended form by specifying
# the reference gpiochip.
#pin: host:gpiochip0/gpio20

[adxl345]
cs_pin: rpi:None
axes_map: x,y,-z
#spi_bus: spi0
#int_pin: 7
#int_pin: 26

[mpu9250]
i2c_mcu: rpi
i2c_bus: i2c.1

[resonance_tester]
accel_chip_x: adxl345
accel_chip_y: mpu9250

max_freq: 200  # Default is 133Hz, increasing gives better high-frequency data
min_freq: 5    # Start measuring from 5Hz
accel_per_hz: 75  # Default is 75, controls amplitude of excitation
hz_per_sec: 1    # Default is 1, controls speed of the test

# Optional but recommended parameters
# damping_ratio: 0.1  # Default is 0.1, helps with signal noise
max_smoothing: 0.10 # 0.05     # Lower values = less smoothing, more detail

probe_points:
  # Somewhere slightly above the middle of your print bed
  86,86,25
  #84,84,25
  # 60,120,20
  # 120,60,20
  #30,30,20
  #50,50,40

[input_shaper]
# Recomputed with dual fans
# Going with = 80 mm/s as that was the max speed that Moonraker reported
# Should have been at 100 mm/s
#
# X:
# at 80 mm/s:  39.86710963
# at 100 mm/s: 49.83388704
# at 100 mm/s: 86.9565 # New
#
# Y:
# at 80 mm/s:  71.30124777 # Works?
# at 100 mm/s: 89.12655971
# at 100 mm/s: 97.7995 # New
#

# shaper_freq_x: 49.8339  # frequency for the X mark of the test model
# shaper_freq_y: 97.7995  # frequency for the Y mark of the test model
# shaper_type: mzv

# New 10 Aug 2023
#shaper_freq_x: 56.10098177  # frequency for the X mark of the test model
#shaper_freq_y: 84.88063660  # frequency for the Y mark of the test model
#shaper_type: mzv

[board_pins]
aliases:
  EXP1_1=PC6,EXP1_3=PB10,EXP1_5=PB14,EXP1_7=PB12,EXP1_9=<GND>,
  EXP1_2=PB2,EXP1_4=PB11,EXP1_6=PB13,EXP1_8=PB15,EXP1_10=<5V>,
  PROBE_IN=PB0,PROBE_OUT=PB1,FIL_RUNOUT=PC6

## ---------------------------------------------------------------------------##
## GCODE Macros
## https://github.com/strayr/strayr-k-macros/blob/main/linear_advance.cfg
# This is useful with slicers that kan send an M900 pressure advance instruction
# It's just a wrapper around SET_PRESSURE_ADVANCE

[gcode_macro M900]
description: Set Linear Advance
gcode:
  {% if 'K' in params %}
    SET_PRESSURE_ADVANCE ADVANCE={params.K|string}
    { action_respond_info("Pressure Advance set to " + params.K|string) }
  {% else %}
    SET_PRESSURE_ADVANCE
  {% endif %}

[gcode_macro M0]
description: Set Linear Advance
gcode:
  PAUSE

[gcode_macro PARK]
description: Park the machine for storage
gcode:
  SET_VELOCITY_LIMIT ACCEL_TO_DECEL=7000
  SET_VELOCITY_LIMIT ACCEL=4000
  SET_VELOCITY_LIMIT VELOCITY=500
  G28
  G1 X82 Y82 Z90

[gcode_macro AUTOMATIC_CALIBRATION]
description: Run all automatic calibration Codes
gcode:
  SET_VELOCITY_LIMIT ACCEL_TO_DECEL=7000
  SET_VELOCITY_LIMIT ACCEL=4000
  SET_VELOCITY_LIMIT VELOCITY=500
  G28
  G1 X75 Y75 Z1
  SHAPER_CALIBRATE AXIS=X
  SHAPER_CALIBRATE AXIS=Y
  PID_CALIBRATE HEATER=extruder TARGET=210
  PID_CALIBRATE HEATER=heater_bed TARGET=60
  SET_HEATER_TEMPERATURE HEATER=extruder TARGET=200
  SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET=60
  G28
  G29
  # SAVE_CONFIG
  PARK

[gcode_macro PID_CALIBRATION]
description: PID CALIBRATE
gcode:
  SET_VELOCITY_LIMIT ACCEL_TO_DECEL=7000
  SET_VELOCITY_LIMIT ACCEL=4000
  SET_VELOCITY_LIMIT VELOCITY=500
  G28
  G1 X75 Y75 Z1
  PID_CALIBRATE HEATER=extruder TARGET=210
  PID_CALIBRATE HEATER=heater_bed TARGET=60

[gcode_macro TUNING_TOWER_INPUT_SHAPER]
description: Setup a Tuning Tower Print
gcode:
  SET_HEATER_TEMPERATURE HEATER=extruder TARGET=200
  SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET=58
  G28
  G29
  SET_VELOCITY_LIMIT ACCEL_TO_DECEL=7000
  SET_PRESSURE_ADVANCE ADVANCE=0
  SET_INPUT_SHAPER SHAPER_TYPE=MZV
  TUNING_TOWER COMMAND=SET_VELOCITY_LIMIT PARAMETER=ACCEL START=6500 STEP_DELTA=500 STEP_HEIGHT=5

##################################
## Add this to your printer.cfg ##
##################################
#####################################################################
# KlackEnder- Settings
#####################################################################

# !! Change your Z endstop pin from 'endstop_pin: Pin123' to 'endstop_pin: probe:z_virtual_endstop'
# !! Also add in [stepper_y] 'position_min: -8'. Idk why but most configs mave this wrong. For the Stock Ender 3 the homed Y position is -8.

[probe]
pin: ^PA7 #^PC14 #Probe-Stop Connection on Skr Mini E3 V1.2
#z_offset = 2.240 # 2.105 #2.4 #2.450 #0 #Measure per your specific setup
x_offset: -4 # negative = left of the nozzle
y_offset: 21 # negative = in front of of the nozzle
speed: 5.0
lift_speed: 15.0
sample_retract_dist: 1
samples: 2
samples_tolerance_retries: 5

##[(7x7)-1] / 2 = 24
##[(5x5)-1] / 2 = 12
[bed_mesh]
speed: 300 #600 #300
horizontal_move_z: 5 #4 #3.5 #4 #2
mesh_min: 16,16
mesh_max: 165,160 #156,156
probe_count: 5,5 # 6,6
# relative_reference_index: 12 # Deprecated
algorithm: bicubic # lagrange
fade_start: 1
fade_end: 10
#fade_target:
#   The z position in which fade should converge. When this value is set
#   to a non-zero value it must be within the range of z-values in the mesh.
#   Users that wish to converge to the z homing position should set this to 0.
#   Default is the average z value of the mesh.
split_delta_z: 0.015
#   The amount of Z difference (in mm) along a move that will
#   trigger a split. Default is .025.
move_check_distance: 3
#   The distance (in mm) along a move to check for split_delta_z.
#   This is also the minimum length that a move can be split. Default
#   is 5.0.
mesh_pps: 2,2 #4,4
#   A comma separated pair of integers (X,Y) defining the number of
#   points per segment to interpolate in the mesh along each axis. A
#   "segment" can be defined as the space between each probed
#   point. The user may enter a single value which will be applied
#   to both axes.  Default is 2,2.
#bicubic_tension: .2
#   When using the bicubic algorithm the tension parameter above
#   may be applied to change the amount of slope interpolated.
#   Larger numbers will increase the amount of slope, which
#   results in more curvature in the mesh. Default is .2.
# BED_MESH_CALIBRATE ADAPTIVE=1
adaptive_margin: 2 # 5

# [bed_screws]
#screw1:
#   The X, Y coordinate of the first bed leveling screw. This is a
#   position to command the nozzle to that is directly above the bed
#   screw (or as close as possible while still being above the bed).
#   This parameter must be provided.
#screw1_name:
#   An arbitrary name for the given screw. This name is displayed when
#   the helper script runs. The default is to use a name based upon
#   the screw XY location.
#screw1_fine_adjust:
#   An X, Y coordinate to command the nozzle to so that one can fine
#   tune the bed leveling screw. The default is to not perform fine
#   adjustments on the bed screw.
#screw2:
#screw2_name:
#screw2_fine_adjust:
#...
#   Additional bed leveling screws. At least three screws must be
#   defined.
#horizontal_move_z: 5
#   The height (in mm) that the head should be commanded to move to
#   when moving from one screw location to the next. The default is 5.
#probe_height: 0
#   The height of the probe (in mm) after adjusting for the thermal
#   expansion of bed and nozzle. The default is zero.
#speed: 50
#   The speed (in mm/s) of non-probing moves during the calibration.
#   The default is 50.
#probe_speed: 5
#   The speed (in mm/s) when moving from a horizontal_move_z position
#   to a probe_height position. The default is 5.

[delayed_gcode bed_mesh_init]
initial_duration: .01
gcode:
  BED_MESH_PROFILE LOAD=default

[homing_override]
set_position_z:0 # Make printer think Z axis is at zero, so we can force a move upwards away from build plate
axes:z # We only want to override homing the z-axis
gcode:
  G90
  G1 Z25 F3000 ; move up to prevent accidentally scratching build plate
  G28 X
  G28 Y
  PROBE_OUT # Disabled for strain guage
  G1 X80 Y60 F6000
  G28 Z
  PROBE_IN # Disabled for strain guage

##For Dual Z setups only!! (with independent motors, no Y splitters or dual Z port on board!)##
#[z_tilt]
#z_positions:
#  25,117
#  210,117
#   A list of X, Y coordinates (one per line; subsequent lines
#   indented) describing the location of each bed "pivot point". The
#   "pivot point" is the point where the bed attaches to the given Z
#   stepper. It is described using nozzle coordinates (the X, Y position
#   of the nozzle if it could move directly above the point). The
#   first entry corresponds to stepper_z, the second to stepper_z1,
#   the third to stepper_z2, etc. This parameter must be provided.
#points:
#  4,96.5
#  219,96.5
#   A list of X, Y coordinates (one per line; subsequent lines
#   indented) that should be probed during a Z_TILT_ADJUST command.
#   Specify coordinates of the nozzle and be sure the probe is above
#   the bed at the given nozzle coordinates. This parameter must be
#   provided.
#speed: 100
#   The speed (in mm/s) of non-probing moves during the calibration.
#   The default is 50.
#horizontal_move_z: 15
#   The height (in mm) that the head should be commanded to move to
#   just prior to starting a probe operation. The default is 5.
#retries: 10
#   Number of times to retry if the probed points aren't within
#   tolerance.
#retry_tolerance: 0.01
#   If retries are enabled then retry if largest and smallest probed
#   points differ more than retry_tolerance. Note the smallest unit of
#   change here would be a single step. However if you are probing
#   more points than steppers then you will likely have a fixed
#   minimum value for the range of probed points which you can learn
#   by observing command output.

#####################################################################
# KlackEnder - Macros
#####################################################################
# Simple way to include all the various klack macros and configurations
# https://github.com/Harrypulvirenti/Klack-Probe-Macros

[include ./klack-variables.cfg]                #Required
[include ./klack-macros.cfg]                   #Required
[include ./klack-bed-mesh-calibrate.cfg]       #bed mesh, requires klipper configuration
#[include ./klack-adaptive-bed-mesh-calibrate.cfg] #Adaptive bed mesh, requires klipper configuration and slicer configuration
#[include ./klack-screws-tilt-calculate.cfg]   #help adjust bed screws automatically, requires klipper configuration

[gcode_macro PROBE_OUT]
gcode:
  #ATTACH_PROBE
  M118 ATTACH_PROBE

[gcode_macro PROBE_IN]
gcode:
  #DOCK_PROBE
  M118 DOCK_PROBE

# Custom macros
[gcode_macro CALIBRATE_XY]
gcode:
  SET_VELOCITY_LIMIT ACCEL_TO_DECEL=7000
  SET_VELOCITY_LIMIT ACCEL=4500
  SET_VELOCITY_LIMIT VELOCITY=500
  G1 X75 Y75 Z1

  SHAPER_CALIBRATE AXIS=X
  SHAPER_CALIBRATE AXIS=y

  SET_VELOCITY_LIMIT ACCEL=3000
  SET_VELOCITY_LIMIT VELOCITY=500

[gcode_macro AUTO_BED_MESH]
gcode:
  SET_VELOCITY_LIMIT ACCEL=1000
  PROBE_OUT # Disabled for strain guage
  G1 Z19
  G1 X15
  BED_MESH_CALIBRATE
  #G1 Y0 F20000
  PROBE_IN # Disabled for strain guage

[gcode_macro PURGE_NOZZLE]
gcode:
  SET_HEATER_TEMPERATURE HEATER=extruder TARGET=230 #Good for PLA and PETG
  SET_VELOCITY_LIMIT ACCEL=3000
  G28
  G1 X80 Y100 Z50
  G1 E100 F360
  G1 E100 F800
  G28 # Do a wipe

[gcode_macro Accuracy_Test]
gcode:
  PROBE_OUT
  G1 Z25
  G1 X25
  G90
  G1 Y80 X80 F20000
  PROBE_ACCURACY
  PROBE_IN


# Old Macros
# [gcode_macro PROBE_OUT]
# gcode:
#   G90
#   G1 X-15 F4000
#   G4 P300
#   G1 Z25
#   G1 X25

# [gcode_macro PROBE_IN]
# gcode:
#   G90
#   G1 Z20
#   G1 X-15 F20000
#   G1 Y-5
#   G1 Z0
#   G4 P300
#   G1 X100 F6000 # 35 130 Move right to catch the probe
#   G1 Z25
#   G1 X25

# [gcode_macro G29]
# gcode:
#   PROBE_OUT
#   G1 Z25
#   G1 X15
#   BED_MESH_CALIBRATE
#   #G1 Y0 F20000
#   PROBE_IN

# [gcode_macro AUTO_Z_TILT_ADJUST]
# gcode:
#   PROBE_OUT
#   Z_TILT_ADJUST
#   PROBE_IN


#####################################################################
# KlackEnder- Menu - Only if you have a display installed!
#####################################################################

[menu __main]
type: list
name: Main

[menu __main __KlackEnder]
type: list
enable: True
name: KlackEnder

[menu __main __KlackEnder __ProbeOut]
type: command
name: Probe Out
gcode:
  PROBE_OUT

[menu __main __KlackEnder __ProbeIn]
type: command
name: Probe In
gcode:
  PROBE_IN

[menu __main __KlackEnder __AutoBedMesh]
type: command
name: Auto Bed Mesh
gcode:
  G28
  AUTO_BED_MESH

## ---------------------------------------------------------------------------##
## Mainsail parts of the config

## Client klipper macro definitions
##
## Copyright (C) 2022 Alex Zellner <alexander.zellner@googlemail.com>
##
## This file may be distributed under the terms of the GNU GPLv3 license
##
## !!! This file is read-only. Maybe the used editor indicates that. !!!
##
## Customization:
##   1) copy the gcode_macro _CLIENT_VARIABLE (see below) to your printer.cfg
##   2) remove the comment mark (#) from all lines
##   3) change any value in there to your needs
##
## Use the PAUSE macro direct in your M600:
##  e.g. with a different park position front left and a minimal height of 50
##    [gcode_macro M600]
##    description: Filament change
##    gcode: PAUSE X=10 Y=10 Z_MIN=50
##  Z_MIN will park the toolhead at a minimum of 50 mm above to bed to make it easier for you to swap filament.
##
## Client variable macro for your printer.cfg
#[gcode_macro _CLIENT_VARIABLE]
#variable_use_custom_pos   : False ; use custom park coordinates for x,y [True/False]
#variable_custom_park_x    : 0.0   ; custom x position; value must be within your defined min and max of X
#variable_custom_park_y    : 0.0   ; custom y position; value must be within your defined min and max of Y
#variable_custom_park_dz   : 2.0   ; custom dz value; the value in mm to lift the nozzle when move to park position
#variable_retract          : 1.0   ; the value to retract while PAUSE
#variable_cancel_retract   : 5.0   ; the value to retract while CANCEL_PRINT
#variable_speed_retract    : 35.0  ; retract speed in mm/s
#variable_unretract        : 1.0   ; the value to unretract while RESUME
#variable_speed_unretract  : 35.0  ; unretract speed in mm/s
#variable_speed_hop        : 15.0  ; z move speed in mm/s
#variable_speed_move       : 100.0 ; move speed in mm/s
#variable_park_at_cancel   : False ; allow to move the toolhead to park while execute CANCEL_PRINT [True/False]
#variable_park_at_cancel_x : None  ; different park position during CANCEL_PRINT [None/Position as Float]; park_at_cancel must be True
#variable_park_at_cancel_y : None  ; different park position during CANCEL_PRINT [None/Position as Float]; park_at_cancel must be True
## !!! Caution [firmware_retraction] must be defined in the printer.cfg if you set use_fw_retract: True !!!
#variable_use_fw_retract  : False ; use fw_retraction instead of the manual version [True/False]
#gcode:

# variable_park_at_cancel: True
# variable_park_at_cancel_x: 30
# variable_park_at_cancel_y: 30

[virtual_sdcard]
path: ~/printer_data/gcodes
on_error_gcode: CANCEL_PRINT

[pause_resume]

[display_status]

[gcode_macro Nozzle_Level]
gcode:
  G1 X85 Y85 Z1 F20000

[gcode_macro CANCEL_PRINT]
  description: Cancel the actual running print
  rename_existing: CANCEL_PRINT_BASE
  gcode:
    #TURN_OFF_HEATERS
    M106 S0
    CANCEL_PRINT_BASE

#   ##### get user parameters or use default #####
#   {% set macro_found = True if printer['gcode_macro _CLIENT_VARIABLE'] is defined else False %}
#   {% set client = printer['gcode_macro _CLIENT_VARIABLE'] %}
#   {% set allow_park = False if not macro_found
#                  else False if client.park_at_cancel is not defined
#                  else True  if client.park_at_cancel|lower == 'true'
#                  else False %}
#   {% set retract = 5.0  if not macro_found else client.cancel_retract|default(5.0)|abs %}
#   ##### define park position #####
#   {% set park_x = ""                                    if not macro_found
#              else ""                                    if client.park_at_cancel_x is not defined
#              else "X=" + client.park_at_cancel_x|string if client.park_at_cancel_x is not none %}
#   {% set park_y = ""                                    if not macro_found
#              else ""                                    if client.park_at_cancel_y is not defined
#              else "Y=" + client.park_at_cancel_y|string if client.park_at_cancel_y is not none %}
#   {% set custom_park = True if (park_x|length > 0 or park_y|length > 0) else False %}
#   ##### end of definitions #####
#   {% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}
#   _CLIENT_RETRACT LENGTH={retract}
#   TURN_OFF_HEATERS
#   M106 S0
#   # clear pause_next_layer and pause_at_layer as preparation for next print
#   SET_PAUSE_NEXT_LAYER ENABLE=0
#   SET_PAUSE_AT_LAYER ENABLE=0 LAYER=0
#   CANCEL_PRINT_BASE

[gcode_macro PAUSE]
description: Pause the actual running print
rename_existing: PAUSE_BASE
gcode:
  SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{printer[printer.toolhead.extruder].target}"

  PAUSE_BASE
  _TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}

[gcode_macro RESUME]
description: Resume the actual running print
rename_existing: RESUME_BASE
variable_last_extruder_temp: 0
gcode:
  ##### get user parameters or use default #####
  {% set macro_found = True if printer['gcode_macro _CLIENT_VARIABLE'] is defined else False %}
  {% set client = printer['gcode_macro _CLIENT_VARIABLE'] %}
  {% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}
  {% set sp_move        = velocity if not macro_found else client.speed_move|default(velocity) %}
  ##### end of definitions #####
  M109 S{last_extruder_temp}

  _CLIENT_EXTRUDE
  RESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}

# Usage: SET_PAUSE_NEXT_LAYER [ENABLE=[0|1]] [MACRO=<name>]
[gcode_macro SET_PAUSE_NEXT_LAYER]
description: Enable a pause if the next layer is reached
gcode:
  {% set pause_next_layer = printer['gcode_macro SET_PRINT_STATS_INFO'].pause_next_layer %}
  {% set ENABLE = params.ENABLE | default(1) | int != 0 %}
  {% set MACRO = params.MACRO | default(pause_next_layer.call, True) %}
  SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ 'enable': ENABLE, 'call': MACRO }}"

# Usage: SET_PAUSE_AT_LAYER [ENABLE=[0|1]] [LAYER=<number>] [MACRO=<name>]
[gcode_macro SET_PAUSE_AT_LAYER]
description: Enable/disable a pause if a given layer number is reached
gcode:
  {% set pause_at_layer = printer['gcode_macro SET_PRINT_STATS_INFO'].pause_at_layer %}
  {% set ENABLE = params.ENABLE | int != 0 if params.ENABLE is defined
             else params.LAYER is defined %}
  {% set LAYER = params.LAYER | default(pause_at_layer.layer) | int %}
  {% set MACRO = params.MACRO | default(pause_at_layer.call, True) %}
  SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ 'enable': ENABLE, 'layer': LAYER, 'call': MACRO }}"

# Usage: SET_PRINT_STATS_INFO [TOTAL_LAYER=<total_layer_count>] [CURRENT_LAYER= <current_layer>]
[gcode_macro SET_PRINT_STATS_INFO]
rename_existing: SET_PRINT_STATS_INFO_BASE
description: Overwrite, to get pause_next_layer and pause_at_layer feature
variable_pause_next_layer: { 'enable': False, 'call': "PAUSE" }
gcode:
  {% if pause_next_layer.enable %}
    {action_respond_info("%s, forced by pause_next_layer" % pause_next_layer.call)}
    {pause_next_layer.call} ; execute the given gcode to pause, should be either M600 or PAUSE
    SET_PAUSE_NEXT_LAYER ENABLE=0
  {% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}
    {action_respond_info("%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer))}
    {pause_at_layer.call} ; execute the given gcode to pause, should be either M600 or PAUSE
    SET_PAUSE_AT_LAYER ENABLE=0
  {% endif %}
  SET_PRINT_STATS_INFO_BASE {rawparams}

##### internal use #####
[gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL]
description: Helper: park toolhead used in PAUSE and CANCEL_PRINT
gcode:
  ##### get user parameters or use default #####
  {% set macro_found = True if printer['gcode_macro _CLIENT_VARIABLE'] is defined else False %}
  {% set client = printer['gcode_macro _CLIENT_VARIABLE'] %}
  {% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}
  {% set use_custom     = False if not macro_found
                     else False if client.use_custom_pos is not defined
                     else True  if client.use_custom_pos|lower == 'true'
                     else False %}
  {% set custom_park_x  = 0.0 if not macro_found else client.custom_park_x|default(0.0) %}
  {% set custom_park_y  = 0.0 if not macro_found else client.custom_park_y|default(0.0) %}
  {% set park_dz        = 2.0 if not macro_found else client.custom_park_dz|default(2.0)|abs %}
  {% set sp_hop         = 900  if not macro_found else client.speed_hop|default(15) * 60 %}
  {% set sp_move        = velocity * 60 if not macro_found else client.speed_move|default(velocity) * 60 %}
  ##### get config and toolhead values #####
  {% set origin    = printer.gcode_move.homing_origin %}
  {% set act       = printer.gcode_move.gcode_position %}
  {% set max       = printer.toolhead.axis_maximum %}
  {% set cone      = printer.toolhead.cone_start_z|default(max.z) %} ; height as long the toolhead can reach max and min of an delta
  {% set round_bed = True if printer.configfile.settings.printer.kinematics is in ['delta','polar','rotary_delta','winch']
                else False %}
  ##### define park position #####
  {% set z_min = params.Z_MIN|default(0)|float %}
  {% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}
  {% set x_park = params.X       if params.X is defined
             else custom_park_x  if use_custom
             else 0.0            if round_bed
             else (max.x - 5.0) %}
  {% set y_park = params.Y       if params.Y is defined
             else custom_park_y  if use_custom
             else (max.y - 5.0)  if round_bed and z_park < cone
             else 0.0            if round_bed
             else (max.y - 5.0) %}
  ##### end of definitions #####
  _CLIENT_RETRACT
  {% if "xyz" in printer.toolhead.homed_axes %}
    G90
    G1 Z{z_park} F{sp_hop}
    G1 X{x_park} Y{y_park} F{sp_move}
    {% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}
  {% else %}
    {action_respond_info("Printer not homed")}
  {% endif %}

[gcode_macro _CLIENT_EXTRUDE]
description: Extrudes, if the extruder is hot enough
gcode:
  {% set macro_found = True if printer['gcode_macro _CLIENT_VARIABLE'] is defined else False %}
  {% set client = printer['gcode_macro _CLIENT_VARIABLE'] %}
  {% set use_fw_retract = False if not macro_found
                     else False if client.use_fw_retract is not defined
                     else True  if client.use_fw_retract|lower == 'true' and printer.firmware_retraction is defined
                     else False %}

  {% set length = (params.LENGTH|float) if params.LENGTH is defined
             else 1.0 if not macro_found
             else client.unretract|default(1.0) %}

  {% set speed = params.SPEED if params.SPEED is defined
            else 35 if not macro_found
            else client.speed_unretract|default(35) %}

  {% set absolute_extrude = printer.gcode_move.absolute_extrude %}

  {% if printer.extruder.can_extrude %}
    {% if use_fw_retract %}
      {% if length < 0 %}
        G10
      {% else %}
        G11
      {% endif %}
    {% else %}
      M83
      G1 E{length} F{(speed|float|abs) * 60}
      {% if absolute_extrude %}
        M82
      {% endif %}
    {% endif %}
  {% else %}
    {action_respond_info("Extruder not hot enough")}
  {% endif %}

[gcode_macro _CLIENT_RETRACT]
description: Retracts, if the extruder is hot enough
gcode:
  {% set macro_found = True if printer['gcode_macro _CLIENT_VARIABLE'] is defined else False %}
  {% set client = printer['gcode_macro _CLIENT_VARIABLE'] %}

  {% set length = (params.LENGTH|float) if params.LENGTH is defined
             else 1.0 if not macro_found
             else client.retract|default(1.0) %}

  {% set speed = params.SPEED if params.SPEED is defined
            else 35 if not macro_found
            else client.speed_retract|default(35) %}

  _CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}

#[delayed_gcode my_delayed_gcode]
#gcode:
#    SET_VELOCITY_LIMIT ACCEL_TO_DECEL=7000
#   A list of G-Code commands to execute when the delay duration has
#   elapsed. G-Code templates are supported. This parameter must be
#   provided.
#initial_duration: 0.0
#   The duration of the initial delay (in seconds). If set to a
#   non-zero value the delayed_gcode will execute the specified number
#   of seconds after the printer enters the "ready" state. This can be
#   useful for initialization procedures or a repeating delayed_gcode.
#   If set to 0 the delayed_gcode will not execute on startup.
#   Default is 0.

# Adding in M204 command
# See: https://github.com/Klipper3d/klipper/issues/2492
# https://github.com/Desuuuu/klipper-macros/blob/master/macros/M204.cfg
#[gcode_macro M204]
#rename_existing: M204.1
#gcode:
#  {% set f = params.F|default(0.5)|float %}
#
#  {% if 'S' in params %}
#    {% set s = params.S|float %}
#    SET_VELOCITY_LIMIT ACCEL={s} ACCEL_TO_DECEL={ s * f }
#  {% else %}
#    {% if 'P' in params %}
#      {% set p = params.P|float %}
#      {% if 'T' in params %}
#        {% set t = params.T|float %}
#        {% if p < t %}
#          SET_VELOCITY_LIMIT ACCEL={p} ACCEL_TO_DECEL={ p * f }
#        {% else %}
#          SET_VELOCITY_LIMIT ACCEL={t} ACCEL_TO_DECEL={ t * f }
#        {% endif %}
#      {% else %}
#        SET_VELOCITY_LIMIT ACCEL={p} ACCEL_TO_DECEL={ p * f }
#      {% endif %}
#    {% elif 'T' in params %}
#      {% set t = params.T|float %}
#      SET_VELOCITY_LIMIT ACCEL={t} ACCEL_TO_DECEL={ t * f }
#    {% endif %}
#  {% endif %}

# Z Offset Calibration
[gcode_macro _Z_CALIBRATION_VARIABLES]
variable_safe_z_height: 20.0          # Safe Z height for movements
variable_start_z_height: 1.0          # Starting height for probing
variable_min_z_height: -0.3           # Minimum Z height to probe
variable_z_step_fine: 0.05            # Fine step size
variable_z_step_coarse: 0.2           # Coarse step size
variable_move_speed: 6000             # XY movement speed in mm/min
variable_probe_speed: 500             # Initial Z probing speed
variable_probe_speed_slow: 300        # Slow probing speed
variable_accel_threshold: 9990.0 #11000.0     # MPU9250 threshold based on your data
variable_samples_per_point: 3         # Number of samples per measurement
variable_measure_delay: 100           # Delay between measurements in ms
variable_consecutive_triggers: 2       # Number of consecutive readings above threshold
variable_test_points: [[86, 86]]      # Test points coordinates
variable_mpu_baseline: 9862.0         # Average baseline from your data
gcode:
  M118 "Z Calibration variables initialized"

[gcode_macro _ACCEL_TEST]
gcode:
  M118 MPU9250
  M118 printer.mpu9250: {printer.mpu9250}
  ACCELEROMETER_MEASURE CHIP=mpu9250 RATE=3500
  M118 printer.mpu9250: {printer.mpu9250}
  ACCELEROMETER_MEASURE CHIP=mpu9250 RATE=3500

  ACCELEROMETER_QUERY CHIP=mpu9250 RATE=3500
  M118 printer.mpu9250: {printer.mpu9250}

  M118 ADXL345
  M118 printer.adxl345: {printer.adxl345}
  ACCELEROMETER_MEASURE CHIP=adxl345 RATE=3500
  M118 printer.adxl345: {printer.adxl345}
  ACCELEROMETER_MEASURE CHIP=adxl345 RATE=3500

  ACCELEROMETER_QUERY CHIP=adxl345 RATE=3500
  M118 printer.adxl345: {printer.adxl345}

[gcode_macro _ACCEL_QUERY_TEST]
gcode:
  M118 MPU9250
  ACCELEROMETER_QUERY CHIP=mpu9250 RATE=3500
  M118 printer.mpu9250: {printer.mpu9250}

  M118 ADXL345
  ACCELEROMETER_QUERY CHIP=adxl345 RATE=3500
  M118 printer.adxl345: {printer.adxl345}

[gcode_macro _ACCEL_CRASH_TEST]
gcode:
  ACCELEROMETER_MEASURE CHIP=mpu9250 RATE=3500
  # ACCELEROMETER_QUERY CHIP=adxl345 RATE=3500

  G1 Z 2.0 F500
  G1 Z-0.4 F500
  G1 Z1.2 F500

  M118 printer.adxl345: {printer.adxl345}
  M118 printer.mpu9250: {printer.mpu9250}

  # ACCELEROMETER_QUERY CHIP=adxl345 RATE=3500
  ACCELEROMETER_MEASURE CHIP=mpu9250 RATE=3500

[gcode_macro _ACCEL_CRASH_TEST_ADXL]
gcode:
  ACCELEROMETER_QUERY CHIP=adxl345 RATE=3500

  G1 Z 2.0 F500
  G1 Z-0.4 F500
  G1 Z1.2 F500

  M118 printer.adxl345: {printer.adxl345}
  M118 printer.mpu9250: {printer.mpu9250}

  ACCELEROMETER_QUERY CHIP=adxl345 RATE=3500

[gcode_macro TEST_MPU_CONTACT]
gcode:
  G28
  G1 X86 Y86 Z5 F6000

  # Start measurements
  ACCELEROMETER_MEASURE CHIP=mpu9250 RATE=3500
  G4 P500  # Wait for sensor to initialize

  # Test in 0.05mm increments
  {% for z in range(20, -20, -1) %}  # From 1mm to -1mm in 0.05mm steps
    {% set z_height = z / 20 %}
    G1 Z{z_height} F240
    ACCELEROMETER_QUERY CHIP=mpu9250 RATE=3500
    ACCELEROMETER_QUERY CHIP=mpu9250 RATE=3500
    #ACCELEROMETER_MEASURE CHIP=mpu9250 RATE=3500
    G4 P100
    M118 "Z height: {z_height}, MPU Z: {printer.mpu9250.z}"
    M118 printer.mpu9250: {printer.mpu9250}
    M118 printer.adxl345: {printer.adxl345}
    #ACCELEROMETER_MEASURE CHIP=mpu9250 RATE=3500
    G4 P100  # Dwell for readings to stabilize
  {% endfor %}

  # Stop measurements
  ACCELEROMETER_MEASURE CHIP=mpu9250 RATE=3500
  G1 Z5 F1000  # Return to safe height

[gcode_macro _MEASURE_MPU]
variable_avg_reading: 0.0
variable_sum_readings: 0.0
gcode:
  {% set vars = printer["gcode_macro _Z_CALIBRATION_VARIABLES"] %}
  {% set local_sum = 0.0 %}

  # ACCELEROMETER_QUERY CHIP=mpu9250 RATE=3500
  ACCELEROMETER_MEASURE CHIP=mpu9250 RATE=3500
  M118 printer.mpu9250: {printer.mpu9250}

  {% for i in range(vars.samples_per_point) %}
      G4 P{vars.measure_delay}
      {% set local_sum = local_sum + printer.mpu9250.z|float %}
      SET_GCODE_VARIABLE MACRO=_MEASURE_MPU VARIABLE=sum_readings VALUE={local_sum}

      # M118 printer.mpu9250.z|float {printer.mpu9250.z|float}
  {% endfor %}

  ACCELEROMETER_MEASURE CHIP=mpu9250 RATE=3500 # End measurement

  SET_GCODE_VARIABLE MACRO=_MEASURE_MPU VARIABLE=avg_reading VALUE={local_sum / vars.samples_per_point}

  M118 "MPU Z readings: Average: {local_sum / vars.samples_per_point}"

[gcode_macro CALIBRATE_Z_PROBE_OFFSET_NEW]
gcode:
  # Save current position and settings
  SAVE_GCODE_STATE NAME=probe_cal

  # Home if needed
  G28

  # Move to center probing position [86,86]
  G90
  G0 X86 Y86 Z2 F3000

  # Start accelerometer measurements
  ACCELEROMETER_MEASURE CHIP=adxl345 NAME=probe_cal

  # Move down slowly until tap detected
  G91
  G0 Z-0.05 F300

  # Query accelerometer in a loop until tap detected
  {% for i in range(400) %}  # 20mm total travel
    ACCELEROMETER_QUERY CHIP=adxl345
    {% if printer.adxl345.tap_detected %}
      break
    {% endif %}
    G0 Z-0.05
  {% endfor %}

  # Get current Z position for offset
  SET_GCODE_VARIABLE MACRO=CALIBRATE_Z_PROBE_OFFSET VARIABLE=found_z VALUE={printer.gcode_move.position.z}

  # Stop measurements and move up
  ACCELEROMETER_MEASURE CHIP=adxl345
  G0 Z10

  # Restore position
  RESTORE_GCODE_STATE NAME=probe_cal

  # Report results
  M118 Found Z offset: {printer.gcode_move.position.z}

[gcode_macro CALIBRATE_Z_OFFSET]
description: Automatically calibrate Z offset using MPU9250 accelerometer data
gcode:
  {% set vars = printer["gcode_macro _Z_CALIBRATION_VARIABLES"] %}

  # Safety checks
  {% if not 'xyz' in printer.toolhead.homed_axes %}
      { action_raise_error("Must home printer first!") }
  {% endif %}

  {% if printer.toolhead.position.z < vars.safe_z_height %}
      G1 Z{vars.safe_z_height} F{vars.move_speed}
  {% endif %}

  # Initialize arrays to store results
  {% set z_offsets = [] %}

  # Test each point
  {% for point in vars.test_points %}
    M118 "Testing point: X{point[0]} Y{point[1]}"

    # Move to test position
    G1 Z{vars.safe_z_height} F{vars.move_speed}
    G1 X{point[0]} Y{point[1]} F{vars.move_speed}

    # Start from safe height
    G1 Z{vars.start_z_height} F{vars.probe_speed}

    # Coarse probing
    {% set found_contact = false %}
    {% set trigger_count = 0 %}
    {% set outer_loop = namespace(continue=false) %}

    {% for z in range((vars.start_z_height * 100)|int, (vars.min_z_height * 100)|int, (-vars.z_step_coarse * 100)|int) %}
      {% if not outer_loop.continue %}
        {% set current_z = z / 100.0 %}

        {% if current_z > 1.0 %}
          G1 Z{current_z} F{vars.probe_speed}
        {% else %}
          G1 Z{current_z} F{vars.probe_speed_slow}
        {% endif %}

        # {% set avg_z_val = printer["gcode_macro _MEASURE_MPU"] %}
        # _MEASURE_MPU
        ACCELEROMETER_QUERY CHIP=mpu9250
        # G4 P{vars.measure_delay}
        M118 "Corase Avg Z value: {avg_z_val}, z: {printer.mpu9250.z|float}"
        # ACCELEROMETER_MEASURE CHIP=mpu9250 RATE=3500

        {% if printer.mpu9250.z|float > vars.accel_threshold %}
          # {% if avg_z_val.avg_reading|float > vars.accel_threshold %}
          {% set trigger_count = trigger_count + 1 %}
          M118 "Trigger count: {trigger_count} at Z: {current_z}"
          {% if trigger_count >= vars.consecutive_triggers %}
            {% set found_contact = true %}
            {% set contact_z = current_z + vars.z_step_coarse %}
            {% set outer_loop.continue = true %}
            M118 "Coarse contact found at Z: {contact_z}"
          {% endif %}
        {% else %}
          {% set trigger_count = 0 %}
        {% endif %}
      {% endif %}
    {% endfor %}

    # Fine probing if contact was found
    {% if found_contact %}
      M118 "Starting fine probing from Z: {contact_z}"
      {% set inner_loop = namespace(continue=false) %}
      {% for z in range((contact_z * 100)|int, ((contact_z - vars.z_step_coarse) * 100)|int, (-vars.z_step_fine * 100)|int) %}
        {% if not inner_loop.continue %}
          {% set current_z = z / 100.0 %}
          G1 Z{current_z} F{vars.probe_speed_slow}

          #{% set avg_z_val = printer["gcode_macro _MEASURE_MPU"] %}
          #_MEASURE_MPU
          ACCELEROMETER_QUERY CHIP=mpu9250
          # G4 P{vars.measure_delay}
          M118 "Corase Avg Z value: {avg_z_val}, z: {printer.mpu9250.z|float}"
          # ACCELEROMETER_MEASURE CHIP=mpu9250 RATE=3500

          {% if printer.mpu9250.z|float > vars.accel_threshold %}
            # {% if avg_z_val.avg_reading|float > vars.accel_threshold %}
            {% set z_offsets = z_offsets + [current_z + vars.z_step_fine] %}
            {% set inner_loop.continue = true %}
            M118 "Fine contact at Z: {current_z}"
          {% endif %}
        {% endif %}
      {% endfor %}
    {% endif %}

    # Return to safe height
    G1 Z{vars.safe_z_height} F{vars.move_speed}
  {% endfor %}

  # Calculate and set the Z offset
  {% if z_offsets|length > 0 %}
    {% set avg_offset = z_offsets|sum / z_offsets|length %}
    SET_GCODE_OFFSET Z={avg_offset} MOVE=1
    M118 "Z offset calibration complete. New offset: {avg_offset}"
    M118 "Individual readings: {z_offsets}"
  {% else %}
    M118 "Z offset calibration failed - no contact points found"
  {% endif %}

  # Return to center and safe height
  G1 X{printer.toolhead.axis_maximum.x/2} Y{printer.toolhead.axis_maximum.y/2} F{vars.move_speed}

#[include shell_command.cfg]
#z_offset = 2.075
#z_offset = 1.850

#*# <---------------------- SAVE_CONFIG ---------------------->
#*# DO NOT EDIT THIS BLOCK OR BELOW. The contents are auto-generated.
#*#
#*# [bed_mesh default]
#*# version = 1
#*# points =
#*#     0.076062, 0.018704, 0.013716, 0.007482, 0.027432
#*#     0.054865, 0.004988, 0.002494, -0.009975, -0.004988
#*#     0.096013, 0.038655, 0.033667, 0.026185, 0.034914
#*#     0.096013, 0.046136, 0.039901, 0.026185, 0.028679
#*#     0.076062, 0.011222, 0.009975, -0.006235, 0.011222
#*# x_count = 5
#*# y_count = 5
#*# mesh_x_pps = 2
#*# mesh_y_pps = 2
#*# algo = bicubic
#*# tension = 0.2
#*# min_x = 16.0
#*# max_x = 165.0
#*# min_y = 16.0
#*# max_y = 160.0
#*#
#*# [probe]
#*# z_offset = 1.475
#*#
#*# [extruder]
#*# control = pid
#*# pid_kp = 23.384
#*# pid_ki = 1.146
#*# pid_kd = 119.259
#*#
#*# [heater_bed]
#*# control = pid
#*# pid_kp = 74.845
#*# pid_ki = 1.647
#*# pid_kd = 850.422
#*#
#*# [input_shaper]
#*# shaper_type_y = mzv
#*# shaper_freq_y = 149.8
#*# shaper_type_x = mzv
#*# shaper_freq_x = 45.2
